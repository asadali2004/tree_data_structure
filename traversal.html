<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tree Traversal Techniques - Tree Data Structures</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .nav-breadcrumb {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .nav-breadcrumb a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .nav-breadcrumb a:hover {
            text-decoration: underline;
        }

        .intro-section {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border-left: 5px solid #2196f3;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 40px;
        }

        .traversal-type {
            margin-bottom: 50px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            border-left: 5px solid #667eea;
        }

        .traversal-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-size: 1.5rem;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .concept-box {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
        }

        .concept-box h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .algorithm-steps {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            border-left: 5px solid #ff9800;
        }

        .algorithm-steps h4 {
            color: #e65100;
            margin-bottom: 15px;
        }

        .algorithm-steps ol {
            margin-left: 20px;
        }

        .algorithm-steps li {
            margin: 8px 0;
            padding: 5px 0;
        }

        .code-container {
            background: #2c3e50;
            border-radius: 10px;
            padding: 20px;
            margin: 25px 0;
            overflow-x: auto;
        }

        .code-header {
            background: #34495e;
            color: white;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            font-weight: bold;
            margin: -20px -20px 15px -20px;
            font-size: 0.9rem;
        }

        .code-block {
            color: #ecf0f1;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            white-space: pre-wrap;
        }

        .code-block .keyword {
            color: #3498db;
            font-weight: bold;
        }

        .code-block .string {
            color: #2ecc71;
        }

        .code-block .comment {
            color: #95a5a6;
            font-style: italic;
        }

        .code-block .method {
            color: #e74c3c;
        }

        .code-block .number {
            color: #f39c12;
        }

        .visual-tree {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .tree-node {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 10px 15px;
            border-radius: 50%;
            margin: 8px;
            font-weight: bold;
            min-width: 40px;
            min-height: 40px;
            line-height: 1.2;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
            transition: all 0.3s ease;
        }

        .tree-node:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .tree-level {
            margin: 20px 0;
            position: relative;
        }

        .tree-connections {
            position: relative;
            margin: 10px 0;
        }

        .tree-connections::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 30px;
            background: #667eea;
        }

        .dfs-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .dfs-card {
            background: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-top: 4px solid;
            transition: all 0.3s ease;
        }

        .dfs-card:nth-child(1) {
            border-top-color: #e74c3c;
        }

        .dfs-card:nth-child(2) {
            border-top-color: #3498db;
        }

        .dfs-card:nth-child(3) {
            border-top-color: #2ecc71;
        }

        .dfs-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .dfs-card h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .traversal-order {
            background: linear-gradient(135deg, #f1f2f6, #dfe4ea);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .significance-box {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border: 2px solid #28a745;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .significance-box h5 {
            color: #155724;
            margin-bottom: 10px;
        }

        .significance-box p {
            color: #155724;
            margin: 0;
        }

        .comparison-section {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 25px;
            margin: 30px 0;
        }

        .comparison-header {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.4rem;
        }

        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .comparison-card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            border-top: 4px solid;
        }

        .recursive-card {
            border-top-color: #3498db;
        }

        .iterative-card {
            border-top-color: #e74c3c;
        }

        .pros-cons {
            margin-top: 15px;
        }

        .pros-cons h5 {
            margin-bottom: 10px;
            color: #2c3e50;
        }

        .pros {
            color: #27ae60;
        }

        .cons {
            color: #e74c3c;
        }

        .example-output {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            margin: 15px 0;
            border-left: 4px solid #3498db;
        }

        .note-box {
            background: linear-gradient(135deg, #fff3cd, #ffeaa7);
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin: 25px 0;
        }

        .note-box h4 {
            color: #856404;
            margin-bottom: 15px;
        }

        .note-box p {
            color: #856404;
            margin: 0;
        }

        .back-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
            text-decoration: none;
            display: inline-block;
        }

        .back-button:hover {
            background: linear-gradient(135deg, #5a6fd8, #6a4190);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .dfs-types,
            .comparison-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîÑ Tree Traversal Techniques</h1>
            <p class="subtitle">Systematic methods for visiting every node in a tree</p>
        </div>

        <div class="nav-breadcrumb">
            <a href="index.html">‚Üê Back to Tree Data Structures Hub</a>
        </div>

        <div class="intro-section">
            <p><strong>Tree traversal</strong> refers to the process of visiting each node in a tree exactly once in a systematic way. Unlike linear data structures (arrays, linked lists), which have a single way to traverse, trees can be traversed in multiple ways. These methods are broadly categorized into two main types: <strong>Breadth-First Search (BFS)</strong> and <strong>Depth-First Search (DFS)</strong>.</p>
        </div>

        <div class="code-container">
            <div class="code-header">üìã TreeNode Class Definition (Java)</div>
            <div class="code-block"><span class="keyword">class</span> <span class="method">TreeNode</span> {
    <span class="keyword">int</span> data;
    <span class="method">TreeNode</span> left;
    <span class="method">TreeNode</span> right;

    <span class="keyword">public</span> <span class="method">TreeNode</span>(<span class="keyword">int</span> data) {
        <span class="keyword">this</span>.data = data;
        <span class="keyword">this</span>.left = <span class="keyword">null</span>;
        <span class="keyword">this</span>.right = <span class="keyword">null</span>;
    }
}</div>
        </div>

        <div class="traversal-type">
            <div class="traversal-header">A. Breadth-First Search (BFS) / Level Order Traversal</div>
            
            <div class="concept-box">
                <h3>üéØ Concept</h3>
                <p><strong>Breadth-First Search (BFS)</strong>, when applied to trees, is commonly known as <strong>Level Order Traversal</strong>. It explores the tree level by level, visiting all nodes at the current depth before moving on to nodes at the next depth. It uses a <strong>queue data structure</strong> to keep track of nodes to visit.</p>
            </div>

            <div class="algorithm-steps">
                <h4>üìù Algorithm Steps</h4>
                <ol>
                    <li>Create an empty queue and enqueue the root node</li>
                    <li>While the queue is not empty:
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>Dequeue a node</li>
                            <li>Process (visit/print) the dequeued node</li>
                            <li>Enqueue all of its children (from left to right)</li>
                        </ul>
                    </li>
                </ol>
            </div>

            <div class="visual-tree">
                <h4 style="margin-bottom: 20px;">Example Tree Structure</h4>
                <div class="tree-level">
                    <span class="tree-node">1</span>
                </div>
                <div class="tree-connections"></div>
                <div class="tree-level">
                    <span class="tree-node">2</span>
                    <span class="tree-node">3</span>
                </div>
                <div class="tree-connections"></div>
                <div class="tree-level">
                    <span class="tree-node">4</span>
                    <span class="tree-node">5</span>
                </div>
                <div class="traversal-order">
                    Level Order Traversal: 1 ‚Üí 2 ‚Üí 3 ‚Üí 4 ‚Üí 5
                </div>
            </div>

            <div class="code-container">
                <div class="code-header">üíª Java Implementation - BFS Level Order Traversal</div>
                <div class="code-block"><span class="keyword">import</span> java.util.LinkedList;
<span class="keyword">import</span> java.util.Queue;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="keyword">public</span> <span class="keyword">class</span> <span class="method">TreeTraversals</span> {

    <span class="keyword">public</span> <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="method">levelOrderTraversal</span>(<span class="method">TreeNode</span> root) {
        <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result = <span class="keyword">new</span> <span class="method">ArrayList</span>&lt;&gt;();
        <span class="keyword">if</span> (root == <span class="keyword">null</span>) {
            <span class="keyword">return</span> result;
        }

        <span class="method">Queue</span>&lt;<span class="method">TreeNode</span>&gt; queue = <span class="keyword">new</span> <span class="method">LinkedList</span>&lt;&gt;();
        queue.<span class="method">offer</span>(root); <span class="comment">// Add root to the queue</span>

        <span class="keyword">while</span> (!queue.<span class="method">isEmpty</span>()) {
            <span class="method">TreeNode</span> current = queue.<span class="method">poll</span>(); <span class="comment">// Remove from front</span>
            result.<span class="method">add</span>(current.data);          <span class="comment">// Process the node</span>

            <span class="comment">// Add children to queue</span>
            <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) {
                queue.<span class="method">offer</span>(current.left);
            }
            <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) {
                queue.<span class="method">offer</span>(current.right);
            }
        }
        <span class="keyword">return</span> result;
    }
    
    // Main method for testing all traversals
    <span class="keyword">public static</span> <span class="keyword">void</span> <span class="method">main</span>(<span class="method">String</span>[] args) {
        <span class="comment">// Construct the example tree:</span>
        <span class="comment">//      1</span>
        <span class="comment">//     / \</span>
        <span class="comment">//    2   3</span>
        <span class="comment">//   / \</span>
        <span class="comment">//  4   5</span>
        <span class="method">TreeNode</span> root = <span class="keyword">new</span> <span class="method">TreeNode</span>(<span class="number">1</span>);
        root.left = <span class="keyword">new</span> <span class="method">TreeNode</span>(<span class="number">2</span>);
        root.right = <span class="keyword">new</span> <span class="method">TreeNode</span>(<span class="number">3</span>);
        root.left.left = <span class="keyword">new</span> <span class="method">TreeNode</span>(<span class="number">4</span>);
        root.left.right = <span class="keyword">new</span> <span class="method">TreeNode</span>(<span class="number">5</span>);

        <span class="method">TreeTraversals</span> traversals = <span class="keyword">new</span> <span class="method">TreeTraversals</span>();

        System.<span class="method">out</span>.<span class="method">println</span>(<span class="string">"Level Order Traversal: "</span> + traversals.<span class="method">levelOrderTraversal</span>(root));
        <span class="comment">// Expected: [1, 2, 3, 4, 5]</span>

        System.<span class="method">out</span>.<span class="method">println</span>(<span class="string">"Inorder Traversal: "</span> + traversals.<span class="method">inorderTraversal</span>(root));
        <span class="comment">// Expected: [4, 2, 5, 1, 3]</span>

        System.<span class="method">out</span>.<span class="method">println</span>(<span class="string">"Preorder Traversal: "</span> + traversals.<span class="method">preorderTraversal</span>(root));
        <span class="comment">// Expected: [1, 2, 4, 5, 3]</span>

        System.<span class="method">out</span>.<span class="method">println</span>(<span class="string">"Postorder Traversal: "</span> + traversals.<span class="method">postorderTraversal</span>(root));
        <span class="comment">// Expected: [4, 5, 2, 3, 1]</span>
        
        System.<span class="method">out</span>.<span class="method">println</span>(<span class="string">"Iterative Preorder Traversal: "</span> + traversals.<span class="method">preorderTraversalIterative</span>(root));
        <span class="comment">// Expected: [1, 2, 4, 5, 3]</span>
    }
}</div>
            </div>

            <div class="example-output">
Expected Output: [1, 2, 3, 4, 5]
            </div>
        </div>

        <div class="traversal-type">
            <div class="traversal-header">B. Depth-First Search (DFS)</div>
            
            <div class="concept-box">
                <h3>üéØ Concept</h3>
                <p><strong>Depth-First Search (DFS)</strong> explores as far as possible along each branch before backtracking. It goes deep into one path until it reaches a leaf node, then it backtracks and explores the next path. DFS typically uses a **stack** (explicit or implicit via recursion) to manage the nodes to visit.</p>
            </div>

            <h3 style="color: #2c3e50; margin: 30px 0 20px 0; font-size: 1.4rem; text-align: center;">Types of DFS for Binary Trees</h3>

            <div class="dfs-types">
                <div class="dfs-card">
                    <h4>üî¥ Inorder Traversal</h4>
                    <p><strong>Order:</strong> Left ‚Üí Root ‚Üí Right</p>
                    
                    <div class="algorithm-steps">
                        <h4>Algorithm:</h4>
                        <ol>
                            <li>Recursively traverse the left subtree</li>
                            <li>Visit the current node</li>
                            <li>Recursively traverse the right subtree</li>
                        </ol>
                    </div>

                    <div class="code-container">
                        <div class="code-header">Java Implementation</div>
                        <div class="code-block"><span class="keyword">public</span> <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="method">inorderTraversal</span>(<span class="method">TreeNode</span> root) {
    <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result = <span class="keyword">new</span> <span class="method">ArrayList</span>&lt;&gt;();
    <span class="method">inorderTraversalRecursive</span>(root, result);
    <span class="keyword">return</span> result;
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="method">inorderTraversalRecursive</span>(<span class="method">TreeNode</span> node, <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result) {
    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;
    
    <span class="method">inorderTraversalRecursive</span>(node.left, result);  <span class="comment">// Left</span>
    result.<span class="method">add</span>(node.data);                      <span class="comment">// Root</span>
    <span class="method">inorderTraversalRecursive</span>(node.right, result); <span class="comment">// Right</span>
}</div>
                    </div>

                    <div class="traversal-order">
                        Example Output: [4, 2, 5, 1, 3]
                    </div>

                    <div class="significance-box">
                        <h5>üîç Special Significance for BSTs</h5>
                        <p>Inorder traversal of a Binary Search Tree always yields nodes in **sorted order**!</p>
                    </div>
                </div>

                <div class="dfs-card">
                    <h4>üîµ Preorder Traversal</h4>
                    <p><strong>Order:</strong> Root ‚Üí Left ‚Üí Right</p>
                    
                    <div class="algorithm-steps">
                        <h4>Algorithm:</h4>
                        <ol>
                            <li>Visit the current node</li>
                            <li>Recursively traverse the left subtree</li>
                            <li>Recursively traverse the right subtree</li>
                        </ol>
                    </div>

                    <div class="code-container">
                        <div class="code-header">Java Implementation</div>
                        <div class="code-block"><span class="keyword">public</span> <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="method">preorderTraversal</span>(<span class="method">TreeNode</span> root) {
    <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result = <span class="keyword">new</span> <span class="method">ArrayList</span>&lt;&gt;();
    <span class="method">preorderTraversalRecursive</span>(root, result);
    <span class="keyword">return</span> result;
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="method">preorderTraversalRecursive</span>(<span class="method">TreeNode</span> node, <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result) {
    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;
    
    result.<span class="method">add</span>(node.data);                      <span class="comment">// Root</span>
    <span class="method">preorderTraversalRecursive</span>(node.left, result);  <span class="comment">// Left</span>
    <span class="method">preorderTraversalRecursive</span>(node.right, result); <span class="comment">// Right</span>
}</div>
                    </div>

                    <div class="traversal-order">
                        Example Output: [1, 2, 4, 5, 3]
                    </div>

                    <div class="significance-box">
                        <h5>üìã Practical Applications</h5>
                        <p>Useful for **creating a copy** of a tree or expressing **prefix expressions**.</p>
                    </div>
                </div>

                <div class="dfs-card">
                    <h4>üü¢ Postorder Traversal</h4>
                    <p><strong>Order:</strong> Left ‚Üí Right ‚Üí Root</p>
                    
                    <div class="algorithm-steps">
                        <h4>Algorithm:</h4>
                        <ol>
                            <li>Recursively traverse the left subtree</li>
                            <li>Recursively traverse the right subtree</li>
                            <li>Visit the current node</li>
                        </ol>
                    </div>

                    <div class="code-container">
                        <div class="code-header">Java Implementation</div>
                        <div class="code-block"><span class="keyword">public</span> <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="method">postorderTraversal</span>(<span class="method">TreeNode</span> root) {
    <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result = <span class="keyword">new</span> <span class="method">ArrayList</span>&lt;&gt;();
    <span class="method">postorderTraversalRecursive</span>(root, result);
    <span class="keyword">return</span> result;
}

<span class="keyword">private</span> <span class="keyword">void</span> <span class="method">postorderTraversalRecursive</span>(<span class="method">TreeNode</span> node, <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result) {
    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;
    
    <span class="method">postorderTraversalRecursive</span>(node.left, result);   <span class="comment">// Left</span>
    <span class="method">postorderTraversalRecursive</span>(node.right, result);  <span class="comment">// Right</span>
    result.<span class="method">add</span>(node.data);                             <span class="comment">// Root</span>
}</div>
                    </div>

                    <div class="traversal-order">
                        Example Output: [4, 5, 2, 3, 1]
                    </div>

                    <div class="significance-box">
                        <h5>üóëÔ∏è Practical Applications</h5>
                        <p>Useful for **deleting a tree** (children before parent) or expressing **postfix expressions**.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="comparison-section">
            <h3 class="comparison-header">‚öñÔ∏è Iterative vs. Recursive DFS Traversal</h3>
            
            <div class="comparison-grid">
                <div class="comparison-card recursive-card">
                    <h4>üîÑ Recursive DFS</h4>
                    <div class="pros-cons">
                        <h5 class="pros">‚úÖ Advantages:</h5>
                        <ul class="pros">
                            <li>Cleaner, more concise code</li>
                            <li>Mirrors conceptual definition directly</li>
                            <li>Easier to understand and implement</li>
                        </ul>
                        
                        <h5 class="cons">‚ùå Disadvantages:</h5>
                        <ul class="cons">
                            <li>Can cause StackOverflowError for deep trees</li>
                            <li>Limited by recursion depth</li>
                            <li>Less control over execution</li>
                        </ul>
                    </div>
                </div>
                
                <div class="comparison-card iterative-card">
                    <h4>üîÅ Iterative DFS</h4>
                    <div class="pros-cons">
                        <h5 class="pros">‚úÖ Advantages:</h5>
                        <ul class="pros">
                            <li>Avoids recursion depth limits</li>
                            <li>Better performance for large trees</li>
                            <li>Explicit control over the stack</li>
                        </ul>
                        
                        <h5 class="cons">‚ùå Disadvantages:</h5>
                        <ul class="cons">
                            <li>More complex to implement</li>
                            <li>Requires careful stack management</li>
                            <li>Less intuitive code structure</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="code-container">
            <div class="code-header">üîÅ Iterative Preorder Traversal Example</div>
            <div class="code-block"><span class="keyword">import</span> java.util.Stack;
<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;

<span class="comment">// This class would be part of the TreeTraversals class or a similar utility</span>
<span class="comment">// For demonstration, assumed to be a method within TreeTraversals</span>
<span class="keyword">public</span> <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; <span class="method">preorderTraversalIterative</span>(<span class="method">TreeNode</span> root) {
    <span class="method">List</span>&lt;<span class="keyword">Integer</span>&gt; result = <span class="keyword">new</span> <span class="method">ArrayList</span>&lt;&gt;();
    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;

    <span class="method">Stack</span>&lt;<span class="method">TreeNode</span>&gt; stack = <span class="keyword">new</span> <span class="method">Stack</span>&lt;&gt;();
    stack.<span class="method">push</span>(root);

    <span class="keyword">while</span> (!stack.<span class="method">isEmpty</span>()) {
        <span class="method">TreeNode</span> current = stack.<span class="method">pop</span>();    <span class="comment">// Pop from top</span>
        result.<span class="method">add</span>(current.data);           <span class="comment">// Process node</span>

        <span class="comment">// Push right first, then left (LIFO ensures left is processed first)</span>
        <span class="keyword">if</span> (current.right != <span class="keyword">null</span>) {
            stack.<span class="method">push</span>(current.right);
        }
        <span class="keyword">if</span> (current.left != <span class="keyword">null</span>) {
            stack.<span class="method">push</span>(current.left);
        }
    }
    <span class="keyword">return</span> result;
}</div>
        </div>

        <div class="example-output">
Expected Output: [1, 2, 4, 5, 3]
        </div>

        <div class="note-box">
            <h4>üìù Important Note on Iterative Inorder/Postorder</h4>
            <p>Iterative Inorder and Postorder are more complex to implement iteratively. Iterative inorder typically involves pushing nodes onto the stack until a null left child is found, then popping and processing, then moving to the right child. Iterative postorder often requires keeping track of whether the right child has been visited or using two stacks. For understanding DFS basics, mastering the recursive versions and iterative preorder is usually sufficient.</p>
        </div>

        <a href="index.html" class="back-button">‚Üê Back to Main Hub</a>
    </div>

    <script>
        // No need for dynamic highlighting as it's now embedded in HTML for consistency with user's images.
        // The previous JavaScript was attempting to add these spans dynamically.
        // Since the user's desired format shows them already present, we assume they are provided in the HTML.
        // If the goal was dynamic highlighting, the previous JS was mostly correct, but the HTML input was wrong.
        // For now, based on the images, we'll keep the spans directly in the HTML code blocks.

        document.addEventListener('DOMContentLoaded', function() {
            const cards = document.querySelectorAll('.dfs-card, .concept-box, .traversal-type');
            
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const observer = new IntersectionObserver(function(entries) {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '0';
                        entry.target.style.transform = 'translateY(20px)';
                        entry.target.style.transition = 'all 0.6s ease';
                        
                        setTimeout(() => {
                            entry.target.style.opacity = '1';
                            entry.target.style.transform = 'translateY(0)';
                        }, 100);
                    }
                });
            }, observerOptions);

            cards.forEach(card => {
                observer.observe(card);
            });

            // Interactive tree nodes
            const treeNodes = document.querySelectorAll('.tree-node');
            treeNodes.forEach(node => {
                node.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.1)';
                    this.style.transition = 'transform 0.2s ease';
                });
                
                node.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                });
            });
        });
    </script>
</body>
</html>