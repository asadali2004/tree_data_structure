<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Types of Trees - Tree Data Structures</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 3px solid #667eea;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .header .subtitle {
            color: #7f8c8d;
            font-size: 1.1rem;
            font-weight: 500;
        }

        .nav-breadcrumb {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .nav-breadcrumb a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
        }

        .nav-breadcrumb a:hover {
            text-decoration: underline;
        }

        .tree-type {
            margin-bottom: 50px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            border-left: 5px solid #667eea;
        }

        .tree-type-header {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            font-size: 1.5rem;
            font-weight: 600;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .definition-box {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            border-left: 5px solid #2196f3;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .characteristics-list {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .characteristics-list h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .characteristics-list ul {
            list-style: none;
            padding: 0;
        }

        .characteristics-list li {
            background: #f8f9fa;
            margin: 8px 0;
            padding: 12px 15px;
            border-radius: 6px;
            border-left: 4px solid #667eea;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .characteristics-list li strong {
            color: #2c3e50;
        }

        .subtypes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .subtype-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            border-top: 4px solid #667eea;
            transition: all 0.3s ease;
        }

        .subtype-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
        }

        .subtype-card h4 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            overflow-x: auto;
            margin: 15px 0;
        }

        .visual-tree {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .tree-node {
            display: inline-block;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 8px 12px;
            border-radius: 50%;
            margin: 5px;
            font-weight: bold;
            min-width: 35px;
            min-height: 35px;
            line-height: 1.2;
            box-shadow: 0 3px 10px rgba(102, 126, 234, 0.3);
        }

        .tree-level {
            margin: 15px 0;
            position: relative;
        }

        .tree-level::after {
            content: '';
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 20px;
            background: #667eea;
        }

        .properties-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .property-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        .property-card:hover {
            border-color: #667eea;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .property-name {
            color: #667eea;
            font-weight: bold;
            font-size: 1.1rem;
            margin-bottom: 8px;
        }

        .property-value {
            color: #495057;
            font-size: 0.95rem;
        }

        .advantages-disadvantages {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 25px 0;
        }

        .pros-cons-card {
            padding: 20px;
            border-radius: 10px;
            border-top: 4px solid;
        }

        .advantages-card {
            background: linear-gradient(135deg, #d4edda, #c3e6cb);
            border-top-color: #28a745;
        }

        .disadvantages-card {
            background: linear-gradient(135deg, #f8d7da, #f5c6cb);
            border-top-color: #dc3545;
        }

        .pros-cons-card h4 {
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .advantages-card h4 {
            color: #155724;
        }

        .disadvantages-card h4 {
            color: #721c24;
        }

        .applications-section {
            background: linear-gradient(135deg, #fff3e0, #ffe0b2);
            border-radius: 12px;
            padding: 25px;
            margin: 25px 0;
            border: 2px solid #ff9800;
        }

        .applications-section h4 {
            color: #e65100;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .formula-box {
            background: #e8f5e8;
            border: 2px solid #4caf50;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2e7d32;
        }

        .rotation-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .rotation-card {
            background: linear-gradient(135deg, #f3e5f5, #e1bee7);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 2px solid #9c27b0;
        }

        .rotation-card h5 {
            color: #4a148c;
            margin-bottom: 10px;
        }

        .color-rules {
            background: #f5f5f5;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .color-rules h4 {
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .rule-item {
            background: white;
            margin: 10px 0;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .back-button {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 30px;
            text-decoration: none;
            display: inline-block;
        }

        .back-button:hover {
            background: linear-gradient(135deg, #5a6fd8, #6a4190);
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .subtypes-grid,
            .properties-grid,
            .advantages-disadvantages {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå≥ Types of Trees</h1>
            <p class="subtitle">Understanding different categories of tree data structures</p>
        </div>

        <div class="nav-breadcrumb">
            <a href="index.html">‚Üê Back to Tree Data Structures Hub</a>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">A. General Trees</div>
            
            <div class="definition-box">
                <p><strong>A General Tree is the most basic form of a tree data structure.</strong> It has no restrictions on the number of children a node can have.</p>
            </div>

            <div class="characteristics-list">
                <h4>Key Characteristics:</h4>
                <ul>
                    <li><strong>Unlimited Children:</strong> A node can have any number of child nodes (zero or more).</li>
                    <li><strong>Hierarchical Structure:</strong> Still maintains the hierarchical parent-child relationship.</li>
                    <li><strong>Acyclic:</strong> No cycles are allowed in the structure.</li>
                </ul>
            </div>

            <div class="applications-section">
                <h4>üìÅ Real-World Example</h4>
                <p>The directory structure of a file system is a perfect example of a general tree, where a directory can contain multiple files or sub-directories.</p>
            </div>

            <div class="code-block">
Implementation Note: Representing general trees can be done using a Node class 
where each node has a list or array of its children.

class Node:
    data
    children[]  // Array or list of child nodes
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">B. Binary Trees</div>
            
            <div class="definition-box">
                <p><strong>A Binary Tree is a special type of general tree</strong> where each node can have at most two children, typically referred to as the "left child" and the "right child."</p>
            </div>

            <div class="characteristics-list">
                <h4>Key Characteristics:</h4>
                <ul>
                    <li><strong>Maximum Two Children:</strong> Each node has at most two children.</li>
                    <li><strong>Order Matters:</strong> The distinction between left and right children is important.</li>
                </ul>
            </div>

            <div class="code-block">
Node Structure (Conceptual):

class Node:
    data
    left_child_pointer
    right_child_pointer
            </div>

            <h3 style="color: #2c3e50; margin: 30px 0 20px 0; font-size: 1.4rem;">Types of Binary Trees:</h3>

            <div class="subtypes-grid">
                <div class="subtype-card">
                    <h4>üî≤ Full Binary Tree</h4>
                    <p><strong>Definition:</strong> Every node has either 0 or 2 children. No node has only one child.</p>
                    
                    <div class="visual-tree">
                        <div class="tree-level">
                            <span class="tree-node">A</span>
                        </div>
                        <div class="tree-level">
                            <span class="tree-node">B</span>
                            <span class="tree-node">C</span>
                        </div>
                        <div class="tree-level">
                            <span class="tree-node">D</span>
                            <span class="tree-node">E</span>
                            <span class="tree-node">F</span>
                            <span class="tree-node">G</span>
                        </div>
                        <p style="margin-top: 15px; color: #666; font-size: 0.9rem;">All internal nodes have exactly 2 children</p>
                    </div>
                </div>

                <div class="subtype-card">
                    <h4>üìä Complete Binary Tree</h4>
                    <p><strong>Definition:</strong> All levels are completely filled except possibly the last level, which must be filled from left to right.</p>
                    
                    <div class="properties-grid">
                        <div class="property-card">
                            <div class="property-name">Array Representation</div>
                            <div class="property-value">
                                ‚Ä¢ Left child at: 2i + 1<br>
                                ‚Ä¢ Right child at: 2i + 2<br>
                                ‚Ä¢ Parent at: (i - 1) // 2
                            </div>
                        </div>
                    </div>
                </div>

                <div class="subtype-card">
                    <h4>‚öñÔ∏è Perfect Binary Tree</h4>
                    <p><strong>Definition:</strong> All internal nodes have exactly two children AND all leaf nodes are at the same depth.</p>
                    
                    <div class="formula-box">
                        Number of nodes N = 2^(h+1) - 1
                        <br>
                        Number of leaves L = 2^h
                    </div>
                </div>

                <div class="subtype-card">
                    <h4>üìê Skewed Binary Tree</h4>
                    <p><strong>Definition:</strong> A tree where every internal node has only one child, resembling a linked list.</p>
                    
                    <div class="disadvantages-card" style="margin-top: 15px;">
                        <h4>‚ö†Ô∏è Performance Issue</h4>
                        <p>Operations degrade to O(n) complexity, defeating the purpose of tree's logarithmic performance.</p>
                    </div>
                </div>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">C. Binary Search Trees (BSTs)</div>
            
            <div class="definition-box">
                <p><strong>A Binary Search Tree (BST) is a special type of binary tree</strong> that maintains a specific ordering property, making it highly efficient for searching, insertion, and deletion operations.</p>
            </div>

            <div class="properties-grid">
                <div class="property-card">
                    <div class="property-name">Left Subtree Property</div>
                    <div class="property-value">All nodes in the left subtree have values less than the parent node.</div>
                </div>
                <div class="property-card">
                    <div class="property-name">Right Subtree Property</div>
                    <div class="property-value">All nodes in the right subtree have values greater than the parent node.</div>
                </div>
                <div class="property-card">
                    <div class="property-name">Recursive Property</div>
                    <div class="property-value">Both left and right subtrees must also be BSTs.</div>
                </div>
                <div class="property-card">
                    <div class="property-name">Uniqueness</div>
                    <div class="property-value">No duplicate values are typically allowed.</div>
                </div>
            </div>

            <div class="advantages-disadvantages">
                <div class="advantages-card">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li><strong>Efficient Searching:</strong> O(log n) average time</li>
                        <li><strong>Efficient Insert/Delete:</strong> O(log n) average time</li>
                        <li><strong>Ordered Retrieval:</strong> In-order traversal gives sorted sequence</li>
                    </ul>
                </div>
                <div class="disadvantages-card">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li><strong>Worst-Case Performance:</strong> O(n) when tree becomes skewed</li>
                        <li><strong>No Auto-Balancing:</strong> Can degenerate into linked list structure</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">D. Heaps</div>
            
            <div class="definition-box">
                <p><strong>A Heap is a complete binary tree</strong> that satisfies the heap property. It is primarily used to implement Priority Queues.</p>
            </div>

            <div class="subtypes-grid">
                <div class="subtype-card">
                    <h4>‚¨áÔ∏è Min-Heap</h4>
                    <div class="formula-box">
                        Parent.value ‚â§ Child.value
                        <br>
                        The minimum element is always at the root.
                    </div>
                </div>

                <div class="subtype-card">
                    <h4>‚¨ÜÔ∏è Max-Heap</h4>
                    <div class="formula-box">
                        Parent.value ‚â• Child.value
                        <br>
                        The maximum element is always at the root.
                    </div>
                </div>
            </div>

            <div class="characteristics-list">
                <h4>Key Characteristics:</h4>
                <ul>
                    <li><strong>Complete Binary Tree:</strong> Allows efficient array representation</li>
                    <li><strong>Root Property:</strong> Always holds the min/max element</li>
                    <li><strong>Not Sorted:</strong> Unlike BST, elements are not in sorted order</li>
                </ul>
            </div>

            <div class="applications-section">
                <h4>üéØ Applications</h4>
                <ul>
                    <li><strong>Priority Queues:</strong> Efficiently get min/max element</li>
                    <li><strong>Heap Sort:</strong> Efficient in-place sorting algorithm</li>
                    <li><strong>Graph Algorithms:</strong> Dijkstra's and Prim's algorithms</li>
                </ul>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">E. AVL Trees (Self-Balancing BSTs)</div>
            
            <div class="definition-box">
                <p><strong>An AVL Tree (Adelson-Velsky and Landis) is a self-balancing Binary Search Tree.</strong> It ensures that the height difference between left and right subtrees of every node is at most 1.</p>
            </div>

            <div class="formula-box">
                Balance Factor = Height(Left Subtree) - Height(Right Subtree)
                <br>
                Must be: -1, 0, or 1
            </div>

            <h4 style="color: #2c3e50; margin: 25px 0 15px 0;">Rotation Types:</h4>
            <div class="rotation-types">
                <div class="rotation-card">
                    <h5>LL Rotation</h5>
                    <p>Right rotation for left-left case</p>
                </div>
                <div class="rotation-card">
                    <h5>RR Rotation</h5>
                    <p>Left rotation for right-right case</p>
                </div>
                <div class="rotation-card">
                    <h5>LR Rotation</h5>
                    <p>Double rotation: left then right</p>
                </div>
                <div class="rotation-card">
                    <h5>RL Rotation</h5>
                    <p>Double rotation: right then left</p>
                </div>
            </div>

            <div class="advantages-disadvantages">
                <div class="advantages-card">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li><strong>Guaranteed Performance:</strong> O(log n) for all operations</li>
                        <li><strong>Height Balanced:</strong> Prevents degeneration</li>
                    </ul>
                </div>
                <div class="disadvantages-card">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li><strong>Complex Implementation:</strong> Balance factor calculations</li>
                        <li><strong>Rotation Overhead:</strong> Additional operations needed</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">F. Red-Black Trees</div>
            
            <div class="definition-box">
                <p><strong>A Red-Black Tree is another self-balancing Binary Search Tree.</strong> While less strictly balanced than AVL trees, it offers comparable O(log n) performance with potentially fewer rotations.</p>
            </div>

            <div class="color-rules">
                <h4>üé® Coloring Rules:</h4>
                <div class="rule-item">
                    <strong>Rule 1:</strong> Every node is either Red or Black
                </div>
                <div class="rule-item">
                    <strong>Rule 2:</strong> The root is Black
                </div>
                <div class="rule-item">
                    <strong>Rule 3:</strong> Every leaf (NIL node) is Black
                </div>
                <div class="rule-item">
                    <strong>Rule 4:</strong> If a node is Red, both children must be Black
                </div>
                <div class="rule-item">
                    <strong>Rule 5:</strong> All paths from node to leaves have same number of Black nodes
                </div>
            </div>

            <div class="advantages-disadvantages">
                <div class="advantages-card">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li><strong>Guaranteed O(log n):</strong> All operations</li>
                        <li><strong>Fewer Rotations:</strong> More efficient than AVL for insertions/deletions</li>
                        <li><strong>Widely Used:</strong> Java TreeMap, Linux kernel</li>
                    </ul>
                </div>
                <div class="disadvantages-card">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li><strong>Color Complexity:</strong> Managing color rules</li>
                        <li><strong>More Complex:</strong> Than basic BSTs</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">G. B-Trees and B+ Trees</div>
            
            <div class="definition-box">
                <p><strong>Specialized tree data structures</strong> primarily designed for efficient storage and retrieval of data on disk, where minimizing disk I/O operations is critical.</p>
            </div>

            <div class="subtypes-grid">
                <div class="subtype-card">
                    <h4>üóÑÔ∏è B-Tree</h4>
                    <p><strong>Definition:</strong> A self-balancing tree where nodes can have multiple children and store multiple keys.</p>
                    
                    <div class="characteristics-list">
                        <h4>Key Features:</h4>
                        <ul>
                            <li>Multiple keys per node</li>
                            <li>All leaves at same depth</li>
                            <li>Reduces disk accesses</li>
                        </ul>
                    </div>

                    <div class="applications-section">
                        <h4>Use Cases:</h4>
                        <ul>
                            <li>File systems (NTFS, HFS+)</li>
                            <li>Database indexing (MySQL, PostgreSQL)</li>
                        </ul>
                    </div>
                </div>

                <div class="subtype-card">
                    <h4>üîó B+ Tree</h4>
                    <p><strong>Definition:</strong> Advanced B-tree where all data pointers are stored only in leaf nodes.</p>
                    
                    <div class="characteristics-list">
                        <h4>Key Features:</h4>
                        <ul>
                            <li>Data only in leaves</li>
                            <li>Linked leaf nodes</li>
                            <li>Excellent for range queries</li>
                        </ul>
                    </div>

                    <div class="applications-section">
                        <h4>Use Cases:</h4>
                        <ul>
                            <li>Database indexes (SQL Server, Oracle)</li>
                            <li>Sequential access optimization</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <div class="tree-type">
            <div class="tree-type-header">H. Trie (Prefix Tree)</div>
            
            <div class="definition-box">
                <p><strong>A Trie (pronounced "try" or "tree")</strong> is a specialized tree-like data structure used to store strings efficiently, particularly useful for prefix-based searches.</p>
            </div>

            <div class="characteristics-list">
                <h4>Key Characteristics:</h4>
                <ul>
                    <li><strong>Prefix Storage:</strong> Each node represents a common prefix</li>
                    <li><strong>Character Edges:</strong> Edges are labeled with characters</li>
                    <li><strong>End Markers:</strong> Nodes store boolean flags for word endings</li>
                    <li><strong>No Duplication:</strong> No character stored twice in same path</li>
                </ul>
            </div>

            <div class="visual-tree">
                <h4 style="margin-bottom: 20px;">Example: Storing "cat", "car", "dog", "cot"</h4>
                <div class="tree-level">
                    <span class="tree-node">root</span>
                </div>
                <div class="tree-level">
                    <span class="tree-node">c</span>
                    <span class="tree-node">d</span>
                </div>
                <div class="tree-level">
                    <span class="tree-node">a</span>
                    <span class="tree-node">o</span>
                    <span class="tree-node">o</span>
                </div>
                <div class="tree-level">
                    <span class="tree-node">t</span>
                    <span class="tree-node">r</span>
                    <span class="tree-node">t</span>
                    <span class="tree-node">g</span>
                </div>
                <p style="margin-top: 15px; color: #666; font-size: 0.9rem;">Blue nodes represent character storage, end markers indicate complete words</p>
            </div>

            <div class="applications-section">
                <h4>üéØ Use Cases</h4>
                <div class="properties-grid">
                    <div class="property-card">
                        <div class="property-name">üîç Autocomplete</div>
                        <div class="property-value">Efficiently suggest words based on prefix input</div>
                    </div>
                    <div class="property-card">
                        <div class="property-name">üìù Spell Checkers</div>
                        <div class="property-value">Quick lookup and validation of words</div>
                    </div>
                    <div class="property-card">
                        <div class="property-name">üåê IP Routing</div>
                        <div class="property-value">Storing IP addresses for longest prefix matching</div>
                    </div>
                    <div class="property-card">
                        <div class="property-name">üìö Dictionaries</div>
                        <div class="property-value">Faster than hash tables for string keys</div>
                    </div>
                </div>
            </div>
        </div>

        <a href="index.html" class="back-button">‚Üê Back to Main Hub</a>
    </div>

    <script>
        // Add smooth scroll animations
        document.addEventListener('DOMContentLoaded', function() {
            const cards = document.querySelectorAll('.subtype-card, .property-card, .tree-type');
            
            const observerOptions = {
                threshold: 0.1,
                rootMargin: '0px 0px -50px 0px'
            };

            const observer = new IntersectionObserver(function(entries) {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = '0';
                        entry.target.style.transform = 'translateY(20px)';
                        entry.target.style.transition = 'all 0.6s ease';
                        
                        setTimeout(() => {
                            entry.target.style.opacity = '1';
                            entry.target.style.transform = 'translateY(0)';
                        }, 100);
                    }
                });
            }, observerOptions);

            cards.forEach(card => {
                observer.observe(card);
            });

            // Interactive tree nodes
            const treeNodes = document.querySelectorAll('.tree-node');
            treeNodes.forEach(node => {
                node.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.1)';
                    this.style.transition = 'transform 0.2s ease';
                });
                
                node.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1)';
                });
            });
        });
    </script>
</body>
</html>